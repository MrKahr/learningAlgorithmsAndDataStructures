# Chapter 1.1
## 1.1-1
Motivation: Given a list of train tickets, we want to sort them in distance from source $s$ to destination $d$, so that the tickets with the shortest distance appear first. 

Input: A list of train tickets $T = {t_1,t_2,\dots t_n}$ where $t_i$ is 
$$
t_i: \text{distance between source and destination}\\
\text{with } t_i \in \real_{\geq0}
$$

Output: A list of tickets $T$ sorted by distance in non-decreasing order. 

Edge cases: If two tickets have the same distance, the first ticket encountered in the input should appear first in the output list - i.e. it should preserve the order in the input list. If there are no tickets, the algorithm should output an empty list. The algorithm outputs single tickets as an unchanged list. 


## 1.1-2
One could consider space efficiency. Space efficiency is important because a computer's memory is finite. 
Algorithms consume memory when applying recursion in the call stack, and when instantiating data structures. Analysing space complexity of an algorithm allows us to reason about how much memory an algorithm uses as a function of its input size $n$.

## 1.1-3
One data structure candidate is a binary balanced search tree(BST). A BST is an ordered data structure that has at most two children for each parent node. The children $c_{right}, c_{left}$ and parent $p$ maintain an invariant order given by the expression $c_{left} \leq p \leq c_{right}$. 

A key strength in searching through a balanced binary tree (BST) is that computation can be done in  $O(lg n)$ time. Balancing ensures that the algorithm avoids the worst case $O(n)$ runtime i.e. cases when the algorithm traverses only right or only left children. 

Weaknesses: To maintain this invariant, the binary tree has to be balanced by some balancing algorithm e.g. in red-black trees. The balancing increases the computational complexity by requiring the algorithm to perform insertions and deletions of nodes.     

## 1.1-4
Travelling salesperson's problems are similar because they are both pathfinding algorithms.  
??????

## 1.1-5 
Real world problems that require finding an optimal solution are frequent in the medical industry. One problem is finding the optimal number of hospital beds $b$ that minimizes expected average wait time $t$ across all patients $p_i$ given that the arrival of patients follows some probability distribution $P$. This problem could be constrained by the number of staff, or the hospital's budget. It could be solved using principles from networking e.g. queing theory.  

Many real world problems do not require computing an optimal solution. One such problem category has been termed planning problem and is found in robotics. The goal of planning problems is to find a sequence of actions such that a set of "facts", known as the universe of predicates $P$, are fulfilled. A planning problem can be formalized as the tuple (S,A,G) which represents the initial state of a problem, possible actions and goal state respectively.

One example of planning problems is that of a robot cleaning tiles of a floor. We denote the set of tiles $T$. To model this problem, we introduce each part of the (S,A,G) formalism separately. 

The initial state $S$ is the set of predicates that describe the truth of the system i.e. ground predicates. In the cleaning problem,  the cleanliness of each tile is represented using the predicate $Clean(t_i)$ where  is a member of $S$ if $t_i$ has been cleaned by the robot. Similarly, $At(t_i) \in S$  if the robot is currently located at tile $t_i$. 

We can formalize the set $S$ as $S = \{At(t_i) | \text{robot is at } t_i\}$ if we assume that no tiles are intially clean.  

The actions that are possible for a robot to perform is represented by the set $A$. 
Every action in $A$ is mapped to a set of predicates that are required for the robot to take an action and a set of predicates that are true after an action has been performed. 
This can be represented as the sets $Pre(a) \subseteq \{Clean(t_i) | t_i \in T\} \cup \{At(t_i)\ | t_i \in T\}, Post(a) \subseteq \{Clean(t_i) | t_i \in T\} \cup \{At(t_i) | t_i \in T\}$ for subset of the complete set of tiles T. 

$G$ represents the goal state of the problem and consists of a set of predicates $G \subseteq P$ that must be true to reach the goal state. 

I know that is possible to further formalize the problem e.g. by defining predicates that indicate whether a move to another tile is possible, but that is beyond the scope of this problem answer. I also know that this is not quite the formalisms that are used in planning tasks, but I am currently practicing those. 

## 1.1-6
One possible problem is packet queing in computer networks. When a router recieves packets from a link, it cannot make any guarentees that all packets from a host are transmitted through the link immediately and may experience some delay. 
The reason is that routers must process packets before they are sent, and therefore has to maintain a packet queue to store incoming packets temporarily for processing.  
  
