# Chapter 1.1
## 1.1-1
Motivation: Given a list of train tickets, we want to sort them in distance from source $s$ to destination $d$, so that the tickets with the shortest distance appear first. 

Input: A list of train tickets $T = {t_1,t_2,\dots t_n}$ where $t_i$ is 
$$
t_i: \text{distance between source and destination}\\
\text{with } t_i \in \real_{\geq0}
$$

Output: A list of tickets $T$ sorted by distance in non-decreasing order. 

Edge cases: If two tickets have the same distance, the first ticket encountered in the input should appear first in the output list - i.e. it should preserve the order in the input list. If there are no tickets, the algorithm should output an empty list. The algorithm outputs single tickets as an unchanged list. 


## 1.1-2
One could consider space efficiency. Space efficiency is important because a computer's memory is finite. 
Algorithms consume memory when applying recursion in the call stack, and when instantiating data structures. Analysing space complexity of an algorithm allows us to reason about how much memory an algorithm uses as a function of its input size $n$.

## 1.1-3
One data structure candidate is a binary balanced search tree(BST). A BST is an ordered data structure that has at most two children for each parent node. The children $c_{right}, c_{left}$ and parent $p$ maintain an invariant order given by the expression $c_{left} \leq p \leq c_{right}$. 

A key strength in searching through a balanced binary tree (BST) is that computation can be done in  $O(lg n)$ time. Balancing ensures that the algorithm avoids the worst case $O(n)$ runtime. 

Weaknesses: To maintain this invariant, the binary tree has to be balanced by some balancing algorithm e.g. in red-black trees. The balancing increases the computational complexity by requiring the algorithm to perform insertions and deletions of nodes.     

## 1.1-4
The shortest path and the travelling salesperson problems are similar in that the. The main difference is 

## 1.1-5 

## 1.1-6
